// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package ibc

import (
	_ "embed"
	"errors"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"

	"github.com/ava-labs/subnet-evm/accounts/abi"
	"github.com/ava-labs/subnet-evm/precompile/contract"
	"github.com/ava-labs/subnet-evm/vmerrs"
)

const (
	CreateClientGasCost uint64 = 1
	UpdateClientGasCost    uint64 = 1
	UpgradeClientGasCost   uint64 = 1

	ConnOpenAckGasCost     uint64 = 1
	ConnOpenConfirmGasCost uint64 = 1
	ConnOpenInitGasCost    uint64 = 1
	ConnOpenTryGasCost     uint64 = 1

)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
	_ = abi.JSON
	_ = errors.New
	_ = big.NewInt
)

// Singleton StatefulPrecompiledContract and signatures.
var (

	// IBCRawABI contains the raw ABI of IBC contract.
	//go:embed contract.abi
	IBCRawABI string

	IBCABI                    = contract.ParseABI(IBCRawABI)
	IBCPrecompile             = createIBCPrecompile()
	GeneratedClientIdentifier = IBCABI.Events["ClientCreated"]

	nextClientSeqStorageKey = common.Hash{'n', 'c', 's', 'e', 'q', 's', 'k'}
	clientStateStorageKey   = common.Hash{'c', 's', 't', 's', 'k'}

	ErrWrongClientType = errors.New("wrong client type. Only Tendermint supported")
)


type ConnOpenAckInput struct {
	ConnectionID             string
	ClientState              []byte
	Version                  []byte
	CounterpartyConnectionID []byte
	ProofTry                 []byte
	ProofClient              []byte
	ProofConsensus           []byte
	ProofHeight              []byte
	ConsensusHeight          []byte
}

type ConnOpenConfirmInput struct {
	ConnectionID string
	ProofAck     []byte
	ProofHeight  []byte
}

type ConnOpenInitInput struct {
	ClientID     string
	Counterparty []byte
	Version      []byte
	DelayPeriod  uint32
}

type ConnOpenTryInput struct {
	Counterparty         []byte
	DelayPeriod          uint32
	ClientID             string
	ClientState          []byte
	CounterpartyVersions []byte
	ProofInit            []byte
	ProofClient          []byte
	ProofConsensus       []byte
	ProofHeight          []byte
	ConsensusHeight      []byte
}

type CreateClientInput struct {
	ClientType     string
	ClientState    []byte
	ConsensusState []byte
}

type UpdateClientInput struct {
	ClientID      string
	ClientMessage []byte
}

type UpgradeClientInput struct {
	ClientID              string
	UpgradePath           []byte
	UpgradedClien         []byte
	UpgradedConsState     []byte
	ProofUpgradeClient    []byte
	ProofUpgradeConsState []byte
}


// UnpackConnOpenAckInput attempts to unpack [input] as ConnOpenAckInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenAckInput(input []byte) (ConnOpenAckInput, error) {
	inputStruct := ConnOpenAckInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenAck", input)

	return inputStruct, err
}

// PackConnOpenAck packs [inputStruct] of type ConnOpenAckInput into the appropriate arguments for connOpenAck.
func PackConnOpenAck(inputStruct ConnOpenAckInput) ([]byte, error) {
	return ContractABI.Pack("connOpenAck", inputStruct.ConnectionID, inputStruct.ClientState, inputStruct.Version, inputStruct.CounterpartyConnectionID, inputStruct.ProofTry, inputStruct.ProofClient, inputStruct.ProofConsensus, inputStruct.ProofHeight, inputStruct.ConsensusHeight)
}

func connOpenAck(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenAckGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenAckInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenAckInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	if err := _connOpenAck(&callOpts[ConnOpenAckInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	}); err != nil {
		return nil, remainingGas, err
	}

	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenConfirmInput attempts to unpack [input] as ConnOpenConfirmInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenConfirmInput(input []byte) (ConnOpenConfirmInput, error) {
	inputStruct := ConnOpenConfirmInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenConfirm", input)

	return inputStruct, err
}

// PackConnOpenConfirm packs [inputStruct] of type ConnOpenConfirmInput into the appropriate arguments for connOpenConfirm.
func PackConnOpenConfirm(inputStruct ConnOpenConfirmInput) ([]byte, error) {
	return ContractABI.Pack("connOpenConfirm", inputStruct.ConnectionID, inputStruct.ProofAck, inputStruct.ProofHeight)
}

func connOpenConfirm(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenConfirmGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenConfirmInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenConfirmInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	if err := _connOpenConfirm(&callOpts[ConnOpenConfirmInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	}); err != nil {
		return nil, remainingGas, err
	}

	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenInitInput attempts to unpack [input] as ConnOpenInitInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenInitInput(input []byte) (ConnOpenInitInput, error) {
	inputStruct := ConnOpenInitInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenInit", input)

	return inputStruct, err
}

// PackConnOpenInit packs [inputStruct] of type ConnOpenInitInput into the appropriate arguments for connOpenInit.
func PackConnOpenInit(inputStruct ConnOpenInitInput) ([]byte, error) {
	return ContractABI.Pack("connOpenInit", inputStruct.ClientID, inputStruct.Counterparty, inputStruct.Version, inputStruct.DelayPeriod)
}

// PackConnOpenInitOutput attempts to pack given connectionID of type string
// to conform the ABI outputs.
func PackConnOpenInitOutput(connectionID string) ([]byte, error) {
	return ContractABI.PackOutput("connOpenInit", connectionID)
}

func connOpenInit(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenInitGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenInitInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenInitInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	connectionID, err := _connOpenInit(&callOpts[ConnOpenInitInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	})
	if err != nil {
		return nil, remainingGas, err
	}

	packedOutput, err := PackConnOpenInitOutput(connectionID)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenTryInput attempts to unpack [input] as ConnOpenTryInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenTryInput(input []byte) (ConnOpenTryInput, error) {
	inputStruct := ConnOpenTryInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenTry", input)

	return inputStruct, err
}

// PackConnOpenTry packs [inputStruct] of type ConnOpenTryInput into the appropriate arguments for connOpenTry.
func PackConnOpenTry(inputStruct ConnOpenTryInput) ([]byte, error) {
	return ContractABI.Pack("connOpenTry", inputStruct.Counterparty, inputStruct.DelayPeriod, inputStruct.ClientID, inputStruct.ClientState, inputStruct.CounterpartyVersions, inputStruct.ProofInit, inputStruct.ProofClient, inputStruct.ProofConsensus, inputStruct.ProofHeight, inputStruct.ConsensusHeight)
}

// PackConnOpenTryOutput attempts to pack given connectionID of type string
// to conform the ABI outputs.
func PackConnOpenTryOutput(connectionID string) ([]byte, error) {
	return ContractABI.PackOutput("connOpenTry", connectionID)
}

func connOpenTry(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenTryGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenTryInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenTryInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	connectionID, err := _connOpenTry(&callOpts[ConnOpenTryInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	})
	if err != nil {
		return nil, remainingGas, err
	}

	packedOutput, err := PackConnOpenTryOutput(connectionID)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackCreateClientInput attempts to unpack [input] as CreateClientInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackCreateClientInput(input []byte) (CreateClientInput, error) {
	inputStruct := CreateClientInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "createClient", input)

	return inputStruct, err
}

// PackCreateClient packs [inputStruct] of type CreateClientInput into the appropriate arguments for createClient.
func PackCreateClient(inputStruct CreateClientInput) ([]byte, error) {
	return ContractABI.Pack("createClient", inputStruct.ClientType, inputStruct.ClientState, inputStruct.ConsensusState)
}

// PackCreateClientOutput attempts to pack given clientID of type string
// to conform the ABI outputs.
func PackCreateClientOutput(clientID string) ([]byte, error) {
	return ContractABI.PackOutput("createClient", clientID)
}

func createClient(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, CreateClientGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the CreateClientInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackCreateClientInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	clientID, err := _createClient(&callOpts[CreateClientInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	})
	if err != nil {
		return nil, remainingGas, err
	}

	packedOutput, err := PackCreateClientOutput(clientID)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackUpdateClientInput attempts to unpack [input] as UpdateClientInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackUpdateClientInput(input []byte) (UpdateClientInput, error) {
	inputStruct := UpdateClientInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "updateClient", input)

	return inputStruct, err
}

// PackUpdateClient packs [inputStruct] of type UpdateClientInput into the appropriate arguments for updateClient.
func PackUpdateClient(inputStruct UpdateClientInput) ([]byte, error) {
	return ContractABI.Pack("updateClient", inputStruct.ClientID, inputStruct.ClientMessage)
}

func updateClient(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, UpdateClientGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the UpdateClientInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackUpdateClientInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	if err := _updateClient(&callOpts[UpdateClientInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	}); err != nil {
		return nil, remainingGas, err
	}

	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackUpgradeClientInput attempts to unpack [input] as UpgradeClientInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackUpgradeClientInput(input []byte) (UpgradeClientInput, error) {
	inputStruct := UpgradeClientInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "upgradeClient", input)

	return inputStruct, err
}

// PackUpgradeClient packs [inputStruct] of type UpgradeClientInput into the appropriate arguments for upgradeClient.
func PackUpgradeClient(inputStruct UpgradeClientInput) ([]byte, error) {
	return ContractABI.Pack("upgradeClient", inputStruct.ClientID, inputStruct.UpgradePath, inputStruct.UpgradedClien, inputStruct.UpgradedConsState, inputStruct.ProofUpgradeClient, inputStruct.ProofUpgradeConsState)
}

func upgradeClient(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, UpgradeClientGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the UpgradeClientInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackUpgradeClientInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	if err := _upgradeClient(&callOpts[UpgradeClientInput]{
		accessibleState: accessibleState,
		caller:          caller,
		addr:            addr,
		suppliedGas:     suppliedGas,
		readOnly:        readOnly,
		args:            inputStruct,
	}); err != nil {
		return nil, remainingGas, err
	}

	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// createIBCPrecompile returns a StatefulPrecompiledContract with getters and setters for the precompile.
func createIBCPrecompile() contract.StatefulPrecompiledContract {
	var functions []*contract.StatefulPrecompileFunction

	abiFunctionMap := map[string]contract.RunStatefulPrecompileFunc{
		"connOpenAck":     connOpenAck,
		"connOpenConfirm": connOpenConfirm,
		"connOpenInit":    connOpenInit,
		"connOpenTry":     connOpenTry,
		"createClient":    createClient,
		"updateClient":    updateClient,
		"upgradeClient":   upgradeClient,
	}

	for name, function := range abiFunctionMap {
		method, ok := IBCABI.Methods[name]
		if !ok {
			panic(fmt.Errorf("given method (%s) does not exist in the ABI", name))
		}
		functions = append(functions, contract.NewStatefulPrecompileFunction(method.ID, function))
	}
	// Construct the contract with no fallback function.
	statefulContract, err := contract.NewStatefulPrecompileContract(nil, functions)
	if err != nil {
		panic(err)
	}
	return statefulContract
}
