package ibc

import (
	"bytes"
	"testing"

	"github.com/ethereum/go-ethereum/common"
)

func TestSplit(t *testing.T) {
	testCases := []struct {
		name   string
		input  []byte
		output []common.Hash
	}{
		{
			"4 bytes",
			[]byte{0xde, 0xad, 0xbe, 0xaf},
			[]common.Hash{common.BytesToHash(common.Hex2Bytes("deadbeaf00000000000000000000000000000000000000000000000000000008"))},
		},
		{
			"8 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
			[]common.Hash{common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeaf000000000000000000000000000000000000000000000010"))},
		},
		{
			"31 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe,
			},
			[]common.Hash{common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbe3e"))},
		},
		{
			"32 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
			[]common.Hash{
				common.BytesToHash(common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000041")),
				common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeaf")),
			},
		},
		{
			"34 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad,
			},
			[]common.Hash{
				common.BytesToHash(common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000045")),
				common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeaf")),
				common.BytesToHash(common.Hex2Bytes("dead000000000000000000000000000000000000000000000000000000000000")),
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := splitState(tc.input)
			if len(tc.output) != len(result) {
				t.Errorf("result lenght mismatch: expected %d got %d", len(tc.output), len(result))

			}
			for i, hash := range tc.output {
				if !bytes.Equal(hash.Bytes(), result[i].Bytes()) {
					t.Errorf("hash %d: expected %+x got %+x", i, hash, result[i])
				}
			}
		})
	}
}

func TestJoin(t *testing.T) {
	testCases := []struct {
		name   string
		input  []common.Hash
		output []byte
	}{
		{
			"4 bytes",
			[]common.Hash{common.BytesToHash(common.Hex2Bytes("deadbeaf00000000000000000000000000000000000000000000000000000008"))},
			[]byte{0xde, 0xad, 0xbe, 0xaf},
		},
		{
			"8 bytes",
			[]common.Hash{common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeaf000000000000000000000000000000000000000000000010"))},
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
		},
		{
			"31 bytes",
			[]common.Hash{common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbe3e"))},
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe,
			},
		},
		{
			"32 bytes",
			[]common.Hash{
				common.BytesToHash(common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000041")),
				common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeaf")),
			},
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
		},
		{
			"34 bytes",
			[]common.Hash{
				common.BytesToHash(common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000049")),
				common.BytesToHash(common.Hex2Bytes("deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeaf")),
				common.BytesToHash(common.Hex2Bytes("deadbeaf00000000000000000000000000000000000000000000000000000000")),
			},
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := joinChunks(tc.input)
			if !bytes.Equal(tc.output, result) {
				t.Errorf("expected %+x got %+x", tc.output, result)
			}
		})
	}
}

func TestChunkSize(t *testing.T) {
	testCases := []struct {
		name      string
		input     []byte
		chunkSize int
	}{
		{
			"4 bytes",
			[]byte{0xde, 0xad, 0xbe, 0xaf},
			1,
		},
		{
			"30 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad,
			},
			1,
		},
		{
			"31 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe,
			},
			1,
		},
		{
			"32 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
			2,
		},
		{
			"63 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe,
			},
			3,
		},
		{
			"64 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
			},
			3,
		},
		{
			"65 bytes",
			[]byte{
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde, 0xad, 0xbe, 0xaf,
				0xde,
			},
			4,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			size := chunkSize(len(tc.input))
			if size != tc.chunkSize {
				t.Errorf("expected %d got %d", tc.chunkSize, size)
			}
		})
	}
}
