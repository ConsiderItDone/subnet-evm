// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package someibc

import (
	"errors"
	"fmt"
	"math/big"

	"github.com/ava-labs/subnet-evm/accounts/abi"
	"github.com/ava-labs/subnet-evm/precompile/contract"
	"github.com/ava-labs/subnet-evm/vmerrs"

	_ "embed"

	"github.com/ethereum/go-ethereum/common"
)

const (
	// Gas costs for each function. These are set to 1 by default.
	// You should set a gas cost for each function in your contract.
	// Generally, you should not set gas costs very low as this may cause your network to be vulnerable to DoS attacks.
	// There are some predefined gas costs in contract/utils.go that you can use.
	OnRecvPacketGasCost        uint64 = 1 /* SET A GAS COST HERE */
	OnTimeoutGasCost           uint64 = 1 /* SET A GAS COST HERE */
	AcknowledgementGasCost     uint64 = 1 /* SET A GAS COST HERE */
	BindPortGasCost            uint64 = 1 /* SET A GAS COST HERE */
	ChanOpenInitGasCost        uint64 = 1 /* SET A GAS COST HERE */
	ChanOpenTryGasCost         uint64 = 1 /* SET A GAS COST HERE */
	ChannelCloseConfirmGasCost uint64 = 1 /* SET A GAS COST HERE */
	ChannelCloseInitGasCost    uint64 = 1 /* SET A GAS COST HERE */
	ChannelOpenAckGasCost      uint64 = 1 /* SET A GAS COST HERE */
	ChannelOpenConfirmGasCost  uint64 = 1 /* SET A GAS COST HERE */
	ConnOpenAckGasCost         uint64 = 1 /* SET A GAS COST HERE */
	ConnOpenConfirmGasCost     uint64 = 1 /* SET A GAS COST HERE */
	ConnOpenInitGasCost        uint64 = 1 /* SET A GAS COST HERE */
	ConnOpenTryGasCost         uint64 = 1 /* SET A GAS COST HERE */
	CreateClientGasCost        uint64 = 1 /* SET A GAS COST HERE */
	RecvPacketGasCost          uint64 = 1 /* SET A GAS COST HERE */
	SendPacketGasCost          uint64 = 1 /* SET A GAS COST HERE */
	TimeoutGasCost             uint64 = 1 /* SET A GAS COST HERE */
	TimeoutOnCloseGasCost      uint64 = 1 /* SET A GAS COST HERE */
	UpdateClientGasCost        uint64 = 1 /* SET A GAS COST HERE */
	UpgradeClientGasCost       uint64 = 1 /* SET A GAS COST HERE */
)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
	_ = abi.JSON
	_ = errors.New
	_ = big.NewInt
)

// Singleton StatefulPrecompiledContract and signatures.
var (

	// ContractRawABI contains the raw ABI of Contract contract.
	//go:embed contract.abi
	ContractRawABI string

	ContractABI = contract.ParseABI(ContractRawABI)

	ContractPrecompile = createContractPrecompile()
)

// Height is an auto generated low-level Go binding around an user-defined struct.
type Height struct {
	RevisionNumber *big.Int
	RevisionHeight *big.Int
}

// IIBCMsgRecvPacket is an auto generated low-level Go binding around an user-defined struct.
type IIBCMsgRecvPacket struct {
	Packet          Packet
	ProofCommitment []byte
	ProofHeight     Height
	Signer          string
}

// Packet is an auto generated low-level Go binding around an user-defined struct.
type Packet struct {
	Sequence           *big.Int
	SourcePort         string
	SourceChannel      string
	DestinationPort    string
	DestinationChannel string
	Data               []byte
	TimeoutHeight      Height
	TimeoutTimestamp   *big.Int
}

type OnRecvPacketInput struct {
	Packet  Packet
	Relayer []byte
}

type OnTimeoutInput struct {
	Packet  Packet
	Relayer []byte
}

type AcknowledgementInput struct {
	Packet          Packet
	Acknowledgement []byte
	ProofAcked      []byte
	ProofHeight     Height
	Signer          string
}

type ChanOpenInitInput struct {
	PortID  string
	Channel []byte
}

type ChanOpenTryInput struct {
	PortID              string
	Channel             []byte
	CounterpartyVersion string
	ProofInit           []byte
	ProofHeight         []byte
}

type ChannelCloseConfirmInput struct {
	PortID      string
	ChannelID   string
	ProofInit   []byte
	ProofHeight []byte
}

type ChannelCloseInitInput struct {
	PortID    string
	ChannelID string
}

type ChannelOpenAckInput struct {
	PortID                string
	ChannelID             string
	CounterpartyChannelID string
	CounterpartyVersion   string
	ProofTry              []byte
	ProofHeight           []byte
}

type ChannelOpenConfirmInput struct {
	PortID      string
	ChannelID   string
	ProofAck    []byte
	ProofHeight []byte
}

type ConnOpenAckInput struct {
	ConnectionID             string
	ClientState              []byte
	Version                  []byte
	CounterpartyConnectionID []byte
	ProofTry                 []byte
	ProofClient              []byte
	ProofConsensus           []byte
	ProofHeight              []byte
	ConsensusHeight          []byte
}

type ConnOpenConfirmInput struct {
	ConnectionID string
	ProofAck     []byte
	ProofHeight  []byte
}

type ConnOpenInitInput struct {
	ClientID     string
	Counterparty []byte
	Version      []byte
	DelayPeriod  uint32
}

type ConnOpenTryInput struct {
	Counterparty         []byte
	DelayPeriod          uint32
	ClientID             string
	ClientState          []byte
	CounterpartyVersions []byte
	ProofInit            []byte
	ProofClient          []byte
	ProofConsensus       []byte
	ProofHeight          []byte
	ConsensusHeight      []byte
}

type CreateClientInput struct {
	ClientType     string
	ClientState    []byte
	ConsensusState []byte
}

type SendPacketInput struct {
	ChannelCapability *big.Int
	SourcePort        string
	SourceChannel     string
	TimeoutHeight     Height
	TimeoutTimestamp  *big.Int
	Data              []byte
}

type TimeoutInput struct {
	Packet           Packet
	ProofUnreceived  []byte
	ProofHeight      Height
	NextSequenceRecv *big.Int
	Signer           string
}

type TimeoutOnCloseInput struct {
	Packet           Packet
	ProofUnreceived  []byte
	ProofClose       []byte
	ProofHeight      Height
	NextSequenceRecv *big.Int
	Signer           string
}

type UpdateClientInput struct {
	ClientID      string
	ClientMessage []byte
}

type UpgradeClientInput struct {
	ClientID              string
	UpgradePath           []byte
	UpgradedClien         []byte
	UpgradedConsState     []byte
	ProofUpgradeClient    []byte
	ProofUpgradeConsState []byte
}

// UnpackOnRecvPacketInput attempts to unpack [input] as OnRecvPacketInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackOnRecvPacketInput(input []byte) (OnRecvPacketInput, error) {
	inputStruct := OnRecvPacketInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "OnRecvPacket", input)

	return inputStruct, err
}

// PackOnRecvPacket packs [inputStruct] of type OnRecvPacketInput into the appropriate arguments for OnRecvPacket.
func PackOnRecvPacket(inputStruct OnRecvPacketInput) ([]byte, error) {
	return ContractABI.Pack("OnRecvPacket", inputStruct.Packet, inputStruct.Relayer)
}

func onRecvPacket(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, OnRecvPacketGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the OnRecvPacketInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackOnRecvPacketInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackOnTimeoutInput attempts to unpack [input] as OnTimeoutInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackOnTimeoutInput(input []byte) (OnTimeoutInput, error) {
	inputStruct := OnTimeoutInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "OnTimeout", input)

	return inputStruct, err
}

// PackOnTimeout packs [inputStruct] of type OnTimeoutInput into the appropriate arguments for OnTimeout.
func PackOnTimeout(inputStruct OnTimeoutInput) ([]byte, error) {
	return ContractABI.Pack("OnTimeout", inputStruct.Packet, inputStruct.Relayer)
}

func onTimeout(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, OnTimeoutGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the OnTimeoutInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackOnTimeoutInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackAcknowledgementInput attempts to unpack [input] as AcknowledgementInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackAcknowledgementInput(input []byte) (AcknowledgementInput, error) {
	inputStruct := AcknowledgementInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "acknowledgement", input)

	return inputStruct, err
}

// PackAcknowledgement packs [inputStruct] of type AcknowledgementInput into the appropriate arguments for acknowledgement.
func PackAcknowledgement(inputStruct AcknowledgementInput) ([]byte, error) {
	return ContractABI.Pack("acknowledgement", inputStruct.Packet, inputStruct.Acknowledgement, inputStruct.ProofAcked, inputStruct.ProofHeight, inputStruct.Signer)
}

func acknowledgement(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, AcknowledgementGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the AcknowledgementInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackAcknowledgementInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackBindPortInput attempts to unpack [input] into the string type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackBindPortInput(input []byte) (string, error) {
	res, err := ContractABI.UnpackInput("bindPort", input)
	if err != nil {
		return "", err
	}
	unpacked := *abi.ConvertType(res[0], new(string)).(*string)
	return unpacked, nil
}

// PackBindPort packs [portID] of type string into the appropriate arguments for bindPort.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackBindPort(portID string) ([]byte, error) {
	return ContractABI.Pack("bindPort", portID)
}

func bindPort(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, BindPortGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the BindPortInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackBindPortInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackChanOpenInitInput attempts to unpack [input] as ChanOpenInitInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackChanOpenInitInput(input []byte) (ChanOpenInitInput, error) {
	inputStruct := ChanOpenInitInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "chanOpenInit", input)

	return inputStruct, err
}

// PackChanOpenInit packs [inputStruct] of type ChanOpenInitInput into the appropriate arguments for chanOpenInit.
func PackChanOpenInit(inputStruct ChanOpenInitInput) ([]byte, error) {
	return ContractABI.Pack("chanOpenInit", inputStruct.PortID, inputStruct.Channel)
}

func chanOpenInit(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ChanOpenInitGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ChanOpenInitInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackChanOpenInitInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackChanOpenTryInput attempts to unpack [input] as ChanOpenTryInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackChanOpenTryInput(input []byte) (ChanOpenTryInput, error) {
	inputStruct := ChanOpenTryInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "chanOpenTry", input)

	return inputStruct, err
}

// PackChanOpenTry packs [inputStruct] of type ChanOpenTryInput into the appropriate arguments for chanOpenTry.
func PackChanOpenTry(inputStruct ChanOpenTryInput) ([]byte, error) {
	return ContractABI.Pack("chanOpenTry", inputStruct.PortID, inputStruct.Channel, inputStruct.CounterpartyVersion, inputStruct.ProofInit, inputStruct.ProofHeight)
}

// PackChanOpenTryOutput attempts to pack given channelID of type string
// to conform the ABI outputs.
func PackChanOpenTryOutput(channelID string) ([]byte, error) {
	return ContractABI.PackOutput("chanOpenTry", channelID)
}

func chanOpenTry(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ChanOpenTryGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ChanOpenTryInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackChanOpenTryInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT

	var output string // CUSTOM CODE FOR AN OUTPUT
	packedOutput, err := PackChanOpenTryOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackChannelCloseConfirmInput attempts to unpack [input] as ChannelCloseConfirmInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackChannelCloseConfirmInput(input []byte) (ChannelCloseConfirmInput, error) {
	inputStruct := ChannelCloseConfirmInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "channelCloseConfirm", input)

	return inputStruct, err
}

// PackChannelCloseConfirm packs [inputStruct] of type ChannelCloseConfirmInput into the appropriate arguments for channelCloseConfirm.
func PackChannelCloseConfirm(inputStruct ChannelCloseConfirmInput) ([]byte, error) {
	return ContractABI.Pack("channelCloseConfirm", inputStruct.PortID, inputStruct.ChannelID, inputStruct.ProofInit, inputStruct.ProofHeight)
}

func channelCloseConfirm(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ChannelCloseConfirmGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ChannelCloseConfirmInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackChannelCloseConfirmInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackChannelCloseInitInput attempts to unpack [input] as ChannelCloseInitInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackChannelCloseInitInput(input []byte) (ChannelCloseInitInput, error) {
	inputStruct := ChannelCloseInitInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "channelCloseInit", input)

	return inputStruct, err
}

// PackChannelCloseInit packs [inputStruct] of type ChannelCloseInitInput into the appropriate arguments for channelCloseInit.
func PackChannelCloseInit(inputStruct ChannelCloseInitInput) ([]byte, error) {
	return ContractABI.Pack("channelCloseInit", inputStruct.PortID, inputStruct.ChannelID)
}

func channelCloseInit(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ChannelCloseInitGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ChannelCloseInitInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackChannelCloseInitInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackChannelOpenAckInput attempts to unpack [input] as ChannelOpenAckInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackChannelOpenAckInput(input []byte) (ChannelOpenAckInput, error) {
	inputStruct := ChannelOpenAckInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "channelOpenAck", input)

	return inputStruct, err
}

// PackChannelOpenAck packs [inputStruct] of type ChannelOpenAckInput into the appropriate arguments for channelOpenAck.
func PackChannelOpenAck(inputStruct ChannelOpenAckInput) ([]byte, error) {
	return ContractABI.Pack("channelOpenAck", inputStruct.PortID, inputStruct.ChannelID, inputStruct.CounterpartyChannelID, inputStruct.CounterpartyVersion, inputStruct.ProofTry, inputStruct.ProofHeight)
}

func channelOpenAck(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ChannelOpenAckGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ChannelOpenAckInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackChannelOpenAckInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackChannelOpenConfirmInput attempts to unpack [input] as ChannelOpenConfirmInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackChannelOpenConfirmInput(input []byte) (ChannelOpenConfirmInput, error) {
	inputStruct := ChannelOpenConfirmInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "channelOpenConfirm", input)

	return inputStruct, err
}

// PackChannelOpenConfirm packs [inputStruct] of type ChannelOpenConfirmInput into the appropriate arguments for channelOpenConfirm.
func PackChannelOpenConfirm(inputStruct ChannelOpenConfirmInput) ([]byte, error) {
	return ContractABI.Pack("channelOpenConfirm", inputStruct.PortID, inputStruct.ChannelID, inputStruct.ProofAck, inputStruct.ProofHeight)
}

func channelOpenConfirm(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ChannelOpenConfirmGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ChannelOpenConfirmInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackChannelOpenConfirmInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenAckInput attempts to unpack [input] as ConnOpenAckInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenAckInput(input []byte) (ConnOpenAckInput, error) {
	inputStruct := ConnOpenAckInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenAck", input)

	return inputStruct, err
}

// PackConnOpenAck packs [inputStruct] of type ConnOpenAckInput into the appropriate arguments for connOpenAck.
func PackConnOpenAck(inputStruct ConnOpenAckInput) ([]byte, error) {
	return ContractABI.Pack("connOpenAck", inputStruct.ConnectionID, inputStruct.ClientState, inputStruct.Version, inputStruct.CounterpartyConnectionID, inputStruct.ProofTry, inputStruct.ProofClient, inputStruct.ProofConsensus, inputStruct.ProofHeight, inputStruct.ConsensusHeight)
}

func connOpenAck(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenAckGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenAckInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenAckInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenConfirmInput attempts to unpack [input] as ConnOpenConfirmInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenConfirmInput(input []byte) (ConnOpenConfirmInput, error) {
	inputStruct := ConnOpenConfirmInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenConfirm", input)

	return inputStruct, err
}

// PackConnOpenConfirm packs [inputStruct] of type ConnOpenConfirmInput into the appropriate arguments for connOpenConfirm.
func PackConnOpenConfirm(inputStruct ConnOpenConfirmInput) ([]byte, error) {
	return ContractABI.Pack("connOpenConfirm", inputStruct.ConnectionID, inputStruct.ProofAck, inputStruct.ProofHeight)
}

func connOpenConfirm(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenConfirmGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenConfirmInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenConfirmInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenInitInput attempts to unpack [input] as ConnOpenInitInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenInitInput(input []byte) (ConnOpenInitInput, error) {
	inputStruct := ConnOpenInitInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenInit", input)

	return inputStruct, err
}

// PackConnOpenInit packs [inputStruct] of type ConnOpenInitInput into the appropriate arguments for connOpenInit.
func PackConnOpenInit(inputStruct ConnOpenInitInput) ([]byte, error) {
	return ContractABI.Pack("connOpenInit", inputStruct.ClientID, inputStruct.Counterparty, inputStruct.Version, inputStruct.DelayPeriod)
}

// PackConnOpenInitOutput attempts to pack given connectionID of type string
// to conform the ABI outputs.
func PackConnOpenInitOutput(connectionID string) ([]byte, error) {
	return ContractABI.PackOutput("connOpenInit", connectionID)
}

func connOpenInit(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenInitGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenInitInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenInitInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT

	var output string // CUSTOM CODE FOR AN OUTPUT
	packedOutput, err := PackConnOpenInitOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackConnOpenTryInput attempts to unpack [input] as ConnOpenTryInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackConnOpenTryInput(input []byte) (ConnOpenTryInput, error) {
	inputStruct := ConnOpenTryInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "connOpenTry", input)

	return inputStruct, err
}

// PackConnOpenTry packs [inputStruct] of type ConnOpenTryInput into the appropriate arguments for connOpenTry.
func PackConnOpenTry(inputStruct ConnOpenTryInput) ([]byte, error) {
	return ContractABI.Pack("connOpenTry", inputStruct.Counterparty, inputStruct.DelayPeriod, inputStruct.ClientID, inputStruct.ClientState, inputStruct.CounterpartyVersions, inputStruct.ProofInit, inputStruct.ProofClient, inputStruct.ProofConsensus, inputStruct.ProofHeight, inputStruct.ConsensusHeight)
}

// PackConnOpenTryOutput attempts to pack given connectionID of type string
// to conform the ABI outputs.
func PackConnOpenTryOutput(connectionID string) ([]byte, error) {
	return ContractABI.PackOutput("connOpenTry", connectionID)
}

func connOpenTry(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ConnOpenTryGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the ConnOpenTryInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackConnOpenTryInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT

	var output string // CUSTOM CODE FOR AN OUTPUT
	packedOutput, err := PackConnOpenTryOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackCreateClientInput attempts to unpack [input] as CreateClientInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackCreateClientInput(input []byte) (CreateClientInput, error) {
	inputStruct := CreateClientInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "createClient", input)

	return inputStruct, err
}

// PackCreateClient packs [inputStruct] of type CreateClientInput into the appropriate arguments for createClient.
func PackCreateClient(inputStruct CreateClientInput) ([]byte, error) {
	return ContractABI.Pack("createClient", inputStruct.ClientType, inputStruct.ClientState, inputStruct.ConsensusState)
}

// PackCreateClientOutput attempts to pack given clientID of type string
// to conform the ABI outputs.
func PackCreateClientOutput(clientID string) ([]byte, error) {
	return ContractABI.PackOutput("createClient", clientID)
}

func createClient(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, CreateClientGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the CreateClientInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackCreateClientInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT

	var output string // CUSTOM CODE FOR AN OUTPUT
	packedOutput, err := PackCreateClientOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackRecvPacketInput attempts to unpack [input] into the IIBCMsgRecvPacket type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackRecvPacketInput(input []byte) (IIBCMsgRecvPacket, error) {
	res, err := ContractABI.UnpackInput("recvPacket", input)
	if err != nil {
		return nil, err
	}
	unpacked := *abi.ConvertType(res[0], new(IIBCMsgRecvPacket)).(*IIBCMsgRecvPacket)
	return unpacked, nil
}

// PackRecvPacket packs [message] of type IIBCMsgRecvPacket into the appropriate arguments for recvPacket.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackRecvPacket(message IIBCMsgRecvPacket) ([]byte, error) {
	return ContractABI.Pack("recvPacket", message)
}

func recvPacket(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, RecvPacketGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the RecvPacketInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackRecvPacketInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackSendPacketInput attempts to unpack [input] as SendPacketInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackSendPacketInput(input []byte) (SendPacketInput, error) {
	inputStruct := SendPacketInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "sendPacket", input)

	return inputStruct, err
}

// PackSendPacket packs [inputStruct] of type SendPacketInput into the appropriate arguments for sendPacket.
func PackSendPacket(inputStruct SendPacketInput) ([]byte, error) {
	return ContractABI.Pack("sendPacket", inputStruct.ChannelCapability, inputStruct.SourcePort, inputStruct.SourceChannel, inputStruct.TimeoutHeight, inputStruct.TimeoutTimestamp, inputStruct.Data)
}

func sendPacket(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, SendPacketGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the SendPacketInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackSendPacketInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackTimeoutInput attempts to unpack [input] as TimeoutInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackTimeoutInput(input []byte) (TimeoutInput, error) {
	inputStruct := TimeoutInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "timeout", input)

	return inputStruct, err
}

// PackTimeout packs [inputStruct] of type TimeoutInput into the appropriate arguments for timeout.
func PackTimeout(inputStruct TimeoutInput) ([]byte, error) {
	return ContractABI.Pack("timeout", inputStruct.Packet, inputStruct.ProofUnreceived, inputStruct.ProofHeight, inputStruct.NextSequenceRecv, inputStruct.Signer)
}

func timeout(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, TimeoutGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the TimeoutInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackTimeoutInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackTimeoutOnCloseInput attempts to unpack [input] as TimeoutOnCloseInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackTimeoutOnCloseInput(input []byte) (TimeoutOnCloseInput, error) {
	inputStruct := TimeoutOnCloseInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "timeoutOnClose", input)

	return inputStruct, err
}

// PackTimeoutOnClose packs [inputStruct] of type TimeoutOnCloseInput into the appropriate arguments for timeoutOnClose.
func PackTimeoutOnClose(inputStruct TimeoutOnCloseInput) ([]byte, error) {
	return ContractABI.Pack("timeoutOnClose", inputStruct.Packet, inputStruct.ProofUnreceived, inputStruct.ProofClose, inputStruct.ProofHeight, inputStruct.NextSequenceRecv, inputStruct.Signer)
}

func timeoutOnClose(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, TimeoutOnCloseGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the TimeoutOnCloseInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackTimeoutOnCloseInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackUpdateClientInput attempts to unpack [input] as UpdateClientInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackUpdateClientInput(input []byte) (UpdateClientInput, error) {
	inputStruct := UpdateClientInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "updateClient", input)

	return inputStruct, err
}

// PackUpdateClient packs [inputStruct] of type UpdateClientInput into the appropriate arguments for updateClient.
func PackUpdateClient(inputStruct UpdateClientInput) ([]byte, error) {
	return ContractABI.Pack("updateClient", inputStruct.ClientID, inputStruct.ClientMessage)
}

func updateClient(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, UpdateClientGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the UpdateClientInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackUpdateClientInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackUpgradeClientInput attempts to unpack [input] as UpgradeClientInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackUpgradeClientInput(input []byte) (UpgradeClientInput, error) {
	inputStruct := UpgradeClientInput{}
	err := ContractABI.UnpackInputIntoInterface(&inputStruct, "upgradeClient", input)

	return inputStruct, err
}

// PackUpgradeClient packs [inputStruct] of type UpgradeClientInput into the appropriate arguments for upgradeClient.
func PackUpgradeClient(inputStruct UpgradeClientInput) ([]byte, error) {
	return ContractABI.Pack("upgradeClient", inputStruct.ClientID, inputStruct.UpgradePath, inputStruct.UpgradedClien, inputStruct.UpgradedConsState, inputStruct.ProofUpgradeClient, inputStruct.ProofUpgradeConsState)
}

func upgradeClient(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, UpgradeClientGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the UpgradeClientInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackUpgradeClientInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// createContractPrecompile returns a StatefulPrecompiledContract with getters and setters for the precompile.

func createContractPrecompile() contract.StatefulPrecompiledContract {
	var functions []*contract.StatefulPrecompileFunction

	abiFunctionMap := map[string]contract.RunStatefulPrecompileFunc{
		"OnRecvPacket":        onRecvPacket,
		"OnTimeout":           onTimeout,
		"acknowledgement":     acknowledgement,
		"bindPort":            bindPort,
		"chanOpenInit":        chanOpenInit,
		"chanOpenTry":         chanOpenTry,
		"channelCloseConfirm": channelCloseConfirm,
		"channelCloseInit":    channelCloseInit,
		"channelOpenAck":      channelOpenAck,
		"channelOpenConfirm":  channelOpenConfirm,
		"connOpenAck":         connOpenAck,
		"connOpenConfirm":     connOpenConfirm,
		"connOpenInit":        connOpenInit,
		"connOpenTry":         connOpenTry,
		"createClient":        createClient,
		"recvPacket":          recvPacket,
		"sendPacket":          sendPacket,
		"timeout":             timeout,
		"timeoutOnClose":      timeoutOnClose,
		"updateClient":        updateClient,
		"upgradeClient":       upgradeClient,
	}

	for name, function := range abiFunctionMap {
		method, ok := ContractABI.Methods[name]
		if !ok {
			panic(fmt.Errorf("given method (%s) does not exist in the ABI", name))
		}
		functions = append(functions, contract.NewStatefulPrecompileFunction(method.ID, function))
	}
	// Construct the contract with no fallback function.
	statefulContract, err := contract.NewStatefulPrecompileContract(nil, functions)
	if err != nil {
		panic(err)
	}
	return statefulContract
}
